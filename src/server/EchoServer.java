// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package server;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.ConnectionToClient;import com.lloseng.ocsf.server.ObservableOriginatorServer;import com.lloseng.ocsf.server.OriginatorMessage;import common.ChatIF;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 6000;    int port;  ObservableOriginatorServer bos;  ChatIF serverUI;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF serverUI)   {	  this.serverUI = serverUI;	  this.port = port;	  this.bos = new ObservableOriginatorServer(port);	  bos.addObserver(this);  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient    (Object msg, ConnectionToClient client)  {	  String message = msg.toString();	  if(message.toString().startsWith("#")){			String[] messsplit = message.split(" ");			switch(messsplit[0]){				case "#login":					if(client.getInfo("id") == null){						if(messsplit.length < 2) {							try {								client.sendToClient("Serveur MSG > Le pseudo est manquant");							} catch (IOException e) {								// TODO Auto-generated catch block								e.printStackTrace();							}						} else {							serverUI.display("lol");							client.setInfo("id",messsplit[1]);							bos.sendToAllClients("Serveur MSG > " + messsplit[1] + " vient de se connecter ...");						}					} else {						try {							client.sendToClient("Serveur MSG > Déja connecté...");						} catch (IOException e) {							// TODO Auto-generated catch block							e.printStackTrace();						}					}					break;			}	  } else {		  		  if(client.getInfo("id") == null){			  try {				client.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		  } else {			    serverUI.display("Message received from client " + client.getInfo("id") + ": " + msg);			    msg = client.getInfo("id") + ": " + msg;			    bos.sendToAllClients(msg);		  }	  }  }    public void handleMessageFromAdmin(String message){	  if(message.startsWith("#")){			String[] messsplit = message.split(" ");			switch(messsplit[0]){				case "#quit":					serverUI.display("Arrêt du serveur...");					try {						bos.sendToAllClients("#quit");						bos.close();					} catch (IOException e1) {						serverUI.display("Impossible de fermer le serveur ...");					}					System.exit(0);					break;				case "#stop":					serverUI.display("Arrêt de l'écoute du serveur ...");					bos.sendToAllClients("#stop");					bos.stopListening();					serverUI.display("Action réussie");					break;				case "#close":					serverUI.display("Arrêt de l'écoute et déconnection des clients ...");					try {						bos.close();						bos.sendToAllClients("#close");					} catch (IOException e1) {						serverUI.display("Impossible de fermer le serveur ...");					}					serverUI.display("Action réussie !");					break;				case "#setport":					if(messsplit[1] == null){						serverUI.display("Port manquant ...");					} else if(bos.isListening()){						serverUI.display("Fermer le serveur avant de changer de port ...");					} else {						this.port = Integer.parseInt(messsplit[1]);						bos.setPort(Integer.parseInt(messsplit[1]));						serverUI.display("Port changé avec succès !");					}					break;				case "#start":					if(bos.isListening()){						serverUI.display("Le serveur est déjà en écoute ...");					} else {						try {							bos.listen();											} catch (IOException e) {							serverUI.display("Problème de lancement du serveur ...");							// TODO Auto-generated catch block						}					}					break;				case "#getport":					serverUI.display("Port " + bos.getPort());					break;			}		}else{		  serverUI.display("Envoi du message \"" + message + "\" aux clients.");		  bos.sendToAllClients("Server msg> " + message);		}  }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    serverUI.display("Server listening for connections on port " + bos.getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    serverUI.display("Server has stopped listening for connections.");  }    protected void serverClosed()  {    serverUI.display("Le serveur s'est éteint.");  }    synchronized protected void clientException(		    ConnectionToClient client, Throwable exception) {	serverUI.display(exception.getMessage());	serverUI.display(client.toString());  }    protected void clientConnected(ConnectionToClient client) {	  serverUI.display(" se connecte...");	  serverUI.display(client.toString());  }    protected void clientDisconnected(ConnectionToClient client) {	  serverUI.display(" se déconnecte...");	  serverUI.display(client.toString());  }    protected void listeningException(ConnectionToClient client) {	  serverUI.display("L'écoute sur le client a été interrompu");	  serverUI.display(client.toString());  }        //Class methods ***************************************************      public ObservableOriginatorServer getObs() {	  return this.bos;  }	@Override	public void update(Observable arg0, Object arg1) {		// TODO Auto-generated method stub		String message = ((OriginatorMessage) arg1).getMessage().toString();		ConnectionToClient client = ((OriginatorMessage) arg1).getOriginator();		if(message.startsWith("#OS")) {			switch(message) {				case ObservableOriginatorServer.CLIENT_CONNECTED:					clientConnected(client);					break;				case ObservableOriginatorServer.CLIENT_DISCONNECTED:					clientDisconnected(client);					break;				case ObservableOriginatorServer.CLIENT_EXCEPTION:					String exception = message.substring(ObservableOriginatorServer.CLIENT_EXCEPTION.length());					clientException(client, new Exception(exception));					break;				case ObservableOriginatorServer.LISTENING_EXCEPTION:					listeningException(client);					break;				case ObservableOriginatorServer.SERVER_CLOSED:					serverClosed();					break;				case ObservableOriginatorServer.SERVER_STARTED:					serverStarted();					break;				case ObservableOriginatorServer.SERVER_STOPPED:					serverStopped();					break;			}		} else {			this.handleMessageFromClient(((OriginatorMessage) arg1).getMessage(), ((OriginatorMessage) arg1).getOriginator());					}	}}//End of EchoServer class