// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package server;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.ConnectionToClient;import com.lloseng.ocsf.server.ObservableOriginatorServer;import com.lloseng.ocsf.server.OriginatorMessage;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {  //Class variables *************************************************    /**   * The default port to listen on.   */  final public static int DEFAULT_PORT = 6000;    Map<ConnectionToClient, String> clientids;  int port;  ObservableOriginatorServer bos;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port)   {    this.port = port;    clientids = new HashMap<>();    this.bos = new ObservableOriginatorServer(port);    bos.addObserver(this);  }    //Instance methods ************************************************    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient    (Object msg, ConnectionToClient client)  {	  String message = msg.toString();	  if(message.toString().startsWith("#")){			String[] messsplit = message.split(" ");			switch(messsplit[0]){				case "#login":					if(client.getInfo("id") == null){						client.setInfo("id",messsplit[1]);					} else {						try {							client.sendToClient("Serveur MSG > Déja connecté...");						} catch (IOException e) {							// TODO Auto-generated catch block							e.printStackTrace();						}					}					break;			}	  } else {		  		  if(client.getInfo("id") == null){			  try {				client.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		  } else {			    System.out.println("Message received from client " + client.getInfo("id") + ": " + msg);			    msg = "Client " + client.getInfo("id") + ": " + msg;			    bos.sendToAllClients(msg);		  }	  }  }    public void handleMessageFromAdmin(String message){	  if(message.startsWith("#")){			String[] messsplit = message.split(" ");			switch(messsplit[0]){				case "#quit":					System.out.println("Arrêt du serveur...");					try {						bos.sendToAllClients("#quit");						bos.close();					} catch (IOException e1) {						System.out.println("Impossible de fermer le serveur ...");					}					System.exit(0);					break;				case "#stop":					System.out.println("Arrêt de l'écoute du serveur ...");					bos.sendToAllClients("#stop");					bos.stopListening();					System.out.println("Action réussie");					break;				case "#close":					System.out.println("Arrêt de l'écoute et déconnection des clients ...");					try {						bos.close();						bos.sendToAllClients("#close");					} catch (IOException e1) {						System.out.println("Impossible de fermer le serveur ...");					}					System.out.println("Action réussie !");					break;				case "#setport":					if(messsplit[1] == null){						System.out.println("Port manquant ...");					} else if(bos.isListening()){						System.out.println("Fermer le serveur avant de changer de port ...");					} else {						this.port = Integer.parseInt(messsplit[1]);						bos.setPort(Integer.parseInt(messsplit[1]));						System.out.println("Port changé avec succès !");					}					break;				case "#start":					if(bos.isListening()){						System.out.println("Le serveur est déjà en écoute ...");					} else {						try {							bos.listen();											} catch (IOException e) {							System.out.println("Problème de lancement du serveur ...");							// TODO Auto-generated catch block						}					}					break;				case "#getport":					System.out.println("Port " + bos.getPort());					break;			}		}else{		  System.out.println("Envoi du message \"" + message + "\" aux clients.");		  bos.sendToAllClients("Server msg> " + message);		}  }      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    System.out.println("Server listening for connections on port " + bos.getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {    System.out.println("Server has stopped listening for connections.");  }    protected void serverClosed()  {    System.out.println("Le serveur s'est éteint.");  }    synchronized protected void clientException(		    ConnectionToClient client, Throwable exception) {	System.out.println(exception.getMessage());	System.out.println(client);  }    protected void clientConnected(ConnectionToClient client) {	  System.out.println(" se connecte...");	  System.out.println(client);  }    protected void clientDisconnected(ConnectionToClient client) {	  System.out.println(" se déconnecte...");	  System.out.println(client);  }    protected void listeningException(ConnectionToClient client) {	  System.out.println("L'écoute sur le client a été interrompu");	  System.out.println(client);  }        //Class methods ***************************************************    /**   * This method is responsible for the creation of    * the server instance (there is no UI in this phase).   *   * @param args[0] The port number to listen on.  Defaults to 5555    *          if no argument is entered.   */  public static void main(String[] args)   {    int port = 0; //Port to listen on    try    {      port = Integer.parseInt(args[0]); //Get port from command line    }    catch(Throwable t)    {      port = DEFAULT_PORT; //Set port to 5555    }	    EchoServer sv = new EchoServer(port);        try     {      sv.getObs().listen(); //Start listening for connections    }     catch (Exception ex)     {      System.out.println("ERROR - Could not listen for clients!");    }  }    public ObservableOriginatorServer getObs() {	  return this.bos;  }	@Override	public void update(Observable arg0, Object arg1) {		// TODO Auto-generated method stub		String message = ((OriginatorMessage) arg1).getMessage().toString();		ConnectionToClient client = ((OriginatorMessage) arg1).getOriginator();		if(message.startsWith("#OS")) {			switch(message) {				case ObservableOriginatorServer.CLIENT_CONNECTED:					clientConnected(client);					break;				case ObservableOriginatorServer.CLIENT_DISCONNECTED:					clientDisconnected(client);					break;				case ObservableOriginatorServer.CLIENT_EXCEPTION:					String exception = message.substring(ObservableOriginatorServer.CLIENT_EXCEPTION.length());					clientException(client, new Exception(exception));					break;				case ObservableOriginatorServer.LISTENING_EXCEPTION:					listeningException(client);					break;				case ObservableOriginatorServer.SERVER_CLOSED:					serverClosed();					break;				case ObservableOriginatorServer.SERVER_STARTED:					serverStarted();					break;				case ObservableOriginatorServer.SERVER_STOPPED:					serverStopped();					break;			}		} else {			this.handleMessageFromClient(((OriginatorMessage) arg1).getMessage(), ((OriginatorMessage) arg1).getOriginator());					}	}}//End of EchoServer class